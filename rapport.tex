\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}

%opening
\title{\textbf{Installations de logiciels :} \\ dépendance, dépôt, gestionnaire de package, installation depuis les sources, environnement virtuel python}

\author{Groupe 2 : Poupelin Bastien, Cherruau Anthony, Thebaudin Corentin}
\date{}

\begin{document}

\maketitle

\tableofcontents

\clearpage

\section{première partie}

\subsection{Dépendance}
\paragraph{}
Les programmes informatiques ne sont pas des briques logicielles isolées : ils s’utilisent les uns les autres, de façon à réduire tant les ressources utilisées par l’ensemble du processus aboutissant à leur exécution (installation sur disque, mise en mémoire, ...), que le temps de codage nécessaire aux programmeurs pour les réaliser. Par exemple, lorsqu’un logiciel lit ou écrit sur un disque, il utilise un sous-programme système existant dans une librairie.

Par extension un certain nombre (de plus en plus, voire énormément...) de programmes utilitaires, automatisant de nombreuses fonctions récurrentes, sont disponibles dans des fichiers librairies partagés (appelés en l’occurrence, Shared Library).

Les programmes peuvent intégrer les sous programmes contenus dans les librairies de deux façons, soit de manière statique ou de manière dynamique.

    de manière statique toutes les sous programmes des librairies sont inclus dans le programme lors de son chargement en mémoire centrale (la taille mémoire centrale nécessaire au programme est donc plus grande).

    de manière dynamique, lors de l’usage d’un sous programme, le programme le charge en mémoire à partir de la librairie qui le contient.

Différents programmes, de différents logiciels, sont donc susceptibles d’utiliser à tout moment des librairies identiques. Celles-ci sont donc identifiées avec précision  et stockées sur disque suivant une arborescence déterminée.

Certaines des distributions GNU/Linux, utilisant les systèmes « rpm » (Redhat, Mandrake) ou « deb » (Debian), gèrent les « dépendances » entre les logiciels utilisateurs et les librairies de sous programmes disponibles. Ce système de gestion des dépendances n’est donc pas inhérent à Linux (noyau dirait-on) mais lié à l’usage de certaines distributions. Malgré tout, sur des distributions ne gérant pas les dépendances, comme la Slackware, l’installation de packages de type tarball (extension .tgz) permet, grâce à des programmes spécifiques (installpkg, pkgtools, removepkg, ...) , de garder une trace de l’installation des logiciels installés et de les désinstaller proprement.

Une librairie de sous programmes ne sera donc installée dans une arborescence connue que si elle n’existe pas déjà quelque part dans le système et dans la bonne version.

Lors de la désinstallation d’un logiciel, une librairie de sous programmes utilisée par celui-ci, ne sera désinstallée que si le compteur de dépendances traçant son usage est à « 0 ». Ceci indiquant qu’elle n’est plus utilisée par aucun des logiciels présents sur le PC.

Le système de « rpm », « « deb » permet donc d’avoir un disque propre et d’installer (désinstaller) des programmes en toute tranquillité, en étant sûr que les librairies nécessaires seront présentes et que celles devenues inutiles seront purgées.


\section{deuxième partie}

\subsection{sous partie}

texte

\subsection{sous partie}

texte

\section{Bloc 3: Réalisation d'un dictionnaire listant le codage de chaque caractère}

\paragraph{}

Ce bloc permettra de coder chaque caractère du fichier à compresser en binaire. C'est cette opération que l'on appellera compression du document.

Pour réaliser ce bloc, il faudra utiliser l'arbre créé auparavant dans le bloc 2. Grâce à cet arbre, on pourra coder chaque caractère en binaire suivant le chemin emprunté dans l'arbre.
Par exemple ici, on établira que pour chaque chemin vers la gauche emprunté, un "0" sera codé pour le caractère trouvé. Lorsque le chemin emprunté est celui du fils droit, le codage sera un "1".

C'est pourquoi la réalisation de ce bloc se basera sur une boucle de lecture de l'arbre. En premier temps la réalisation de cette lecture serait faite de manière préfixe, avec une variable binaire qui contiendrait le codage du caractère, s'incrémentant par un décalage de bit à chaque mouvement dans l'arbre jusqu'à attendre une feuille. Par soucis de temps et de solutions, un second choix a été réalisé: L'arbre sera lu de haut en bas jusqu'à atteindre une feuille, le codage et le caractère sera écrit dans le fichier puis la feuille sera supprimée. La lecture sera relancée, jusqu'à ce que l'arbre soit vide.

\end{document}
